<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Air Canvas</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        #container {
            display: flex;
        }
        #videoContainer {
            position: relative;
        }
        #video {
            width: 640px;
            height: 480px;
        }
        #landmarksCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
        }
        #drawingCanvas {
            width: 640px;
            height: 480px;
            background-color: white;
        }
        #modeDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: blue;
            font-size: 20px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="videoContainer">
            <video id="video" autoplay></video>
            <canvas id="landmarksCanvas"></canvas>
            <div id="modeDisplay">Mode: IDLE</div>
        </div>
        <canvas id="drawingCanvas"></canvas>
    </div>
    <script>
        const socket = io();
        const video = document.getElementById('video');
        const landmarksCanvas = document.getElementById('landmarksCanvas');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const modeDisplay = document.getElementById('modeDisplay');
        const landmarksCtx = landmarksCanvas.getContext('2d');
        const drawingCtx = drawingCanvas.getContext('2d');
        
        let prevCursorPos = null;
        const cursorSize = 20;
        const brushThickness = 5;
        const eraserThickness = 20;
        
        // Access webcam
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                video.srcObject = stream;
            })
            .catch(err => console.error('Webcam error:', err));
        
        // Send frames to server every 100ms
        setInterval(() => {
            if (video.videoWidth > 0) {  // Ensure video is ready
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                canvas.toBlob(blob => {
                    blob.arrayBuffer().then(buffer => {
                        socket.emit('frame', buffer);
                    });
                }, 'image/jpeg');
            }
        }, 100);
        
        socket.on('update', data => {
            // Clear landmarks canvas
            landmarksCtx.clearRect(0, 0, landmarksCanvas.width, landmarksCanvas.height);
            
            // Update mode display
            modeDisplay.textContent = `Mode: ${data.mode.toUpperCase()}`;
            
            // Draw landmarks if present
            if (data.landmarks) {
                data.landmarks.forEach(lm => {
                    const x = lm[0] * landmarksCanvas.width;
                    const y = lm[1] * landmarksCanvas.height;
                    landmarksCtx.beginPath();
                    landmarksCtx.arc(x, y, 5, 0, 2 * Math.PI);
                    landmarksCtx.fillStyle = 'red';
                    landmarksCtx.fill();
                });
            }
            
            // Handle drawing and cursor
            if (data.cursor_pos) {
                const cursorX = data.cursor_pos[0];
                const cursorY = data.cursor_pos[1];
                
                // Draw on canvas based on mode
                if (data.mode === 'draw' && prevCursorPos) {
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(prevCursorPos[0], prevCursorPos[1]);
                    drawingCtx.lineTo(cursorX, cursorY);
                    drawingCtx.strokeStyle = 'black';
                    drawingCtx.lineWidth = brushThickness;
                    drawingCtx.stroke();
                } else if (data.mode === 'eraser' && prevCursorPos) {
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(prevCursorPos[0], prevCursorPos[1]);
                    drawingCtx.lineTo(cursorX, cursorY);
                    drawingCtx.strokeStyle = 'white';
                    drawingCtx.lineWidth = eraserThickness;
                    drawingCtx.stroke();
                }
                
                // Draw cursor based on mode
                if (data.mode === 'draw') {
                    // Brush cursor: circle with tail
                    landmarksCtx.beginPath();
                    landmarksCtx.arc(cursorX, cursorY, cursorSize / 2, 0, 2 * Math.PI);
                    landmarksCtx.fillStyle = 'black';
                    landmarksCtx.fill();
                    landmarksCtx.beginPath();
                    landmarksCtx.moveTo(cursorX, cursorY + cursorSize / 2);
                    landmarksCtx.lineTo(cursorX, cursorY + cursorSize);
                    landmarksCtx.strokeStyle = 'black';
                    landmarksCtx.lineWidth = 2;
                    landmarksCtx.stroke();
                } else if (data.mode === 'eraser') {
                    // Eraser cursor: rectangle
                    landmarksCtx.beginPath();
                    landmarksCtx.rect(cursorX - cursorSize, cursorY - cursorSize / 2, cursorSize * 2, cursorSize);
                    landmarksCtx.strokeStyle = 'red';
                    landmarksCtx.lineWidth = 2;
                    landmarksCtx.stroke();
                } else {
                    // Idle cursor: plus sign
                    landmarksCtx.beginPath();
                    landmarksCtx.moveTo(cursorX - cursorSize / 2, cursorY);
                    landmarksCtx.lineTo(cursorX + cursorSize / 2, cursorY);
                    landmarksCtx.moveTo(cursorX, cursorY - cursorSize / 2);
                    landmarksCtx.lineTo(cursorX, cursorY + cursorSize / 2);
                    landmarksCtx.strokeStyle = 'green';
                    landmarksCtx.lineWidth = 2;
                    landmarksCtx.stroke();
                }
                
                prevCursorPos = [cursorX, cursorY];
            } else {
                prevCursorPos = null;
            }
        });
        
        // Optional: Add controls (e.g., clear canvas)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'c') {
                drawingCtx.fillStyle = 'white';
                drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }
        });
    </script>
</body>
</html>